---
title: 测试基础

date: 2025-03-01
lastmod: 2025-03-01
tags:
- 基础知识
---



# 测试指标

## 测试覆盖率

测试覆盖率(（Test Coverage)是测试用例执行时，系统或代码的覆盖程度。它反映了测试是否覆盖了系统的各个方面，包括功能、代码、路径等。

不同的测试覆盖率指标提供了对测试的不同层面的检查。一般来说：

- **语句覆盖率**和**分支覆盖率**是最常用的基础覆盖率，适用于大多数场景。
- **路径覆盖率**和**多条件覆盖率**适用于复杂的系统，特别是那些有大量分支和复杂条件的系统。
- **函数覆盖率**、**调用路径覆盖率**等适用于验证系统中的函数调用和路径的完整性。

### 功能覆盖率

功能覆盖率（Functional Coverage）是指测试用例对系统中所有功能点的覆盖程度。它确保每个功能都得到了测试。计算方法为：
$$
功能覆盖率 = （已执行的功能点数量 / 总功能点数量）× 100\%
$$
**应用场景**：

- 适用于验证系统是否实现了所有设计或需求文档中的功能。
- 适合功能测试，确保所有业务流程、用例和需求都已测试。

### 语句覆盖率

语句覆盖率（Statement Coverage）是指测试用例执行过程中，程序中每个语句被执行的次数。它衡量了代码中每一行是否都被测试过。计算方法为：
$$
语句覆盖率 = （已执行的语句数量 / 总语句数量）× 100\%
$$
**应用场景**：

- 适用于测试代码是否执行过每一行，特别是代码逻辑简单且不复杂时。

### 分支覆盖率

分支覆盖率（Branch Coverage）是指测试用例覆盖程序中每个**分支点**的程度。它确保每个条件的两个结果（True 和 False）都至少被执行一次。计算方法为：
$$
分支覆盖率 = （已执行的分支数量 / 总分支数量）× 100\%
$$
**应用场景**：

- 适用于检查条件语句（如`if`、`else`）的所有可能结果是否都被覆盖。
- 比语句覆盖率更精细，因为它考虑了条件的所有可能分支。

###  条件覆盖率

条件覆盖率（Condition Coverage）是指每个条件（如`if`语句中的条件部分）被测试用例覆盖的情况。它确保每个条件表达式的所有结果（True 和 False）都被执行过。计算方法为：
$$
条件覆盖率 = （已执行的条件数量 / 总条件数量）× 100\%
$$
**应用场景**：

- 适用于对单个条件进行验证，特别是在复合条件语句中，确保每个条件都独立地进行了验证。

### 路径覆盖率

路径覆盖率（Path Coverage）是指测试用例覆盖了程序中每条独立路径的程度。它比分支覆盖率和语句覆盖率更加细致，考虑程序的所有可能执行路径。计算方法为：
$$
路径覆盖率 = （已执行的路径数量 / 总路径数量）× 100\%
$$
**应用场景**：

- 适用于对复杂的程序进行全面的验证，尤其是涉及多分支、循环的代码块。

### 条件-决策覆盖率

条件-决策覆盖率（Condition-Decision Coverage, CDC）结合了条件覆盖率和分支覆盖率，确保每个条件表达式的所有结果以及每个决策（如`if`、`else`）的所有分支都被测试。计算方法为：
$$
条件-决策覆盖率 = （已执行的条件-决策点数量 / 总条件-决策点数量）× 100\%
$$
**应用场景**：

- 适用于确保测试用例对条件和决策的覆盖面都全面。

### 循环覆盖率

循环覆盖率（Loop Coverage）是指测试用例覆盖程序中的循环结构的程度。它确保每个循环的**进入**、**退出**及**重复执行**都被测试过。

**计算方法**：
$$
循环覆盖率 = （已执行的循环次数 / 总循环次数）× 100\%
$$
**应用场景**：

- 适用于存在循环结构的程序（如`for`、`while`循环），确保循环条件和边界情况都得到充分验证。

### 函数覆盖率

函数覆盖率（Function Coverage）是指测试用例是否覆盖了系统中所有函数的调用。计算方法为：
$$
函数覆盖率 = （已执行的函数数量 / 总函数数量）× 100\%
$$
**应用场景**：

- 适用于对软件系统中的函数或方法进行验证，确保每个函数都有被调用到。

### 调用路径覆盖率

调用路径覆盖率（Call Coverage）是指测试用例覆盖程序中各个函数调用的情况，确保每个函数都至少被调用一次。计算方法为：
$$
调用路径覆盖率 = （已调用的函数路径数量 / 总函数路径数量）× 100\%
$$
**应用场景**：

- 适用于复杂系统中函数之间的调用关系验证，确保系统的功能通过各个函数调用得到了执行。

### 多条件覆盖率

多条件覆盖率（Multiple Condition Coverage）是指测试用例是否覆盖了多个条件组合的所有可能结果，确保每种条件组合都被测试过。计算方法为：
$$
多条件覆盖率 = （已测试的条件组合数量 / 总条件组合数量）× 100\%
$$
**应用场景**：

- 适用于具有多个条件组合的系统，确保每种组合的可能性都被验证。

## 缺陷密度

缺陷密度（Defect Density）指的是每千行代码（KLOC）中发现的缺陷数量。它是衡量软件质量的一个重要指标。评估标准为：

- 缺陷密度越高，说明软件质量越差，可能存在很多隐藏的缺陷。
- 一般来说，在不同阶段的缺陷密度有所不同，开发阶段缺陷密度较高，测试阶段和发布前缺陷密度较低。

**通过标准**：

- 一般来说，低于0.5个缺陷/千行代码（KLOC）为良好的质量标准，但具体要求会根据项目的复杂性和行业标准有所不同。

## 缺陷发现率

缺陷发现率（Defect Discovery Rate）是指每单位时间内（如每日、每周、每月）发现的缺陷数量。它能够帮助评估测试进度和测试的效率。评估标准为：

- 高缺陷发现率可能意味着测试阶段的有效性较高。
- 如果缺陷发现率急剧下降，可能意味着大部分缺陷已经被发现，或者测试没有覆盖到关键的功能区域。

**通过标准**：

- 随着测试进度的推进，缺陷发现率应该逐渐降低，测试结束前如果没有新的严重缺陷被发现，说明测试已经接近完成。

## 缺陷修复率

缺陷修复率（Defect Fix Rate）是指在发现缺陷后，修复缺陷的速度和效率。它可以反映开发团队对缺陷的响应速度和处理能力。评估标准为：

- 高修复率表示开发团队对缺陷的及时响应和高效修复。
- 修复率过低可能表明问题没有及时得到处理，或者缺陷修复的质量不高。

**通过标准**：

- 理想的缺陷修复率应该接近100%，即所有发现的缺陷都应得到修复，尤其是高优先级缺陷。

## 测试执行率

测试执行率（Test Execution Rate）是指在给定时间内，实际执行的测试用例数量与计划测试用例总数之间的比例。评估标准为：

- 高执行率表示测试团队按照计划执行测试，测试进度顺利。
- 低执行率可能意味着测试工作滞后，测试覆盖不全面。

**通过标准**：

- 测试执行率通常期望达到100%，即所有计划的测试用例都应在测试阶段执行完毕。

## 测试缺陷重开率

缺陷重开率（Defect Reopen Rate）是指已经标记为解决的缺陷，在后续的测试中再次被发现或被测试人员重新标记为有效缺陷的比例。评估标准为：

- 如果缺陷重开率较高，表明缺陷修复不彻底，或者修复后的回归测试没有有效执行。
- 较低的重开率通常意味着缺陷修复彻底，解决方案有效。

**通过标准**：

- 理想情况下，缺陷重开率应尽可能低。如果重开率较高，可能需要对缺陷修复过程进行审查，并提高修复质量。

## 回归测试通过率

回归测试通过率（Regression Test Pass Rate）是指回归测试过程中通过的测试用例占总回归测试用例的比例。评估标准为：

- 高回归测试通过率表明系统的修改不会破坏现有的功能，系统在修复或新增功能后仍然稳定。
- 如果回归测试通过率较低，可能意味着修改引入了新的缺陷或不兼容的改变。

**通过标准**：

- 一般来说，回归测试通过率应接近100%，特别是在关键功能区域。

## 测试效率

测试效率（Test Efficiency）是指测试用例执行中发现缺陷的比例。它帮助评估测试用例设计和执行的质量。评估标准为：

- 高测试效率表示测试用例设计得当，能够有效地找到软件中的缺陷。
- 低测试效率可能意味着测试用例不够全面，或测试覆盖不到关键路径。

**通过标准**：

- 理想情况下，测试效率应较高，至少达到20%-30%，即每执行3-5个测试用例，能发现1个缺陷。

## 用户验收测试（UAT）通过率

**定义**：用户验收测试通过率是指用户验收测试过程中，符合用户需求的测试用例通过的比例。评估标准为：

- 高通过率意味着软件满足用户的预期需求和业务需求。
- 低通过率可能表明软件与用户需求存在较大差距。

**通过标准**：

- 用户验收测试通过率通常期望达到100%，即系统完全符合用户的需求。

# 测试方法

## 黑盒测试
- **定义**：不关注内部代码，只测试功能。
- **方法**：
  - **等价类划分**：将输入数据分为有效和无效类。
  - **边界值分析**：测试输入范围的边界值。
  - **决策表测试**：基于条件组合设计测试用例。
  - **状态转换测试**：测试系统在不同状态下的行为。
  - **用例测试**：根据用户场景设计测试。

## 白盒测试
- **定义**：基于代码内部结构设计测试。
- **方法**：
  - **语句覆盖**：确保每条语句至少执行一次。
  - **分支覆盖**：确保每个分支至少执行一次。
  - **路径覆盖**：测试所有可能的执行路径。
  - **条件覆盖**：确保每个条件的所有可能结果都被测试。

## 灰盒测试
- **定义**：结合黑盒和白盒测试，部分了解内部结构。
- **方法**：
  - **集成测试**：测试模块间的交互。
  - **回归测试**：确保新代码不影响现有功能。

## 手动测试
- **定义**：人工执行测试用例。
- **方法**：
  - **探索性测试**：无预设用例，自由探索。
  - **用户验收测试**：由最终用户验证系统是否符合需求。

## 自动化测试
- **定义**：使用工具或脚本自动执行测试。
- **方法**：
  - **单元测试**：测试单个代码单元。
  - **集成测试**：测试多个模块的交互。
  - **性能测试**：评估系统性能。
  - **负载测试**：测试系统在高负载下的表现。
  - **压力测试**：测试系统在极限条件下的表现。

## 性能测试
- **定义**：评估系统在不同条件下的性能。
- **方法**：
  - **负载测试**：模拟多用户或高数据量。
  - **压力测试**：测试系统在极限条件下的表现。
  - **容量测试**：确定系统能处理的最大负载。

## 安全测试
- **定义**：评估系统的安全性。
- **方法**：
  - **漏洞扫描**：查找已知漏洞。
  - **渗透测试**：模拟攻击测试系统防护。
  - **安全代码审查**：检查代码中的安全漏洞。

## 兼容性测试
- **定义**：测试系统在不同环境下的兼容性。
- **方法**：
  - **跨浏览器测试**：测试不同浏览器的兼容性。
  - **跨平台测试**：测试不同操作系统或设备的兼容性。

## 可用性测试
- **定义**：评估系统的用户体验。
- **方法**：
  - **用户测试**：让真实用户使用并提供反馈。
  - **A/B测试**：比较不同设计或功能的效果。

## 回归测试
- **定义**：确保新代码不影响现有功能。
- **方法**：
  - **自动化回归测试**：使用自动化工具执行回归测试。
  - **手动回归测试**：人工执行回归测试。



# 测试用例的设计方法

## 等价类划分法

等价类划分是一种通过将输入数据划分为不同的等价类来减少测试用例数量的方法。每个等价类中的数据被认为是等价的，即他们在程序中会被系统地处理为相同的方式。

主要步骤为：

- 输入划分：根据输入数据的特性，划分出有效等价类和无效等价类。
  - **有效等价类**：程序应该正常处理的输入范围。
  - **无效等价类**：程序应该拒绝或抛出错误的输入范围。
- **测试用例选择**：从每个等价类中选择一个代表性测试用例。

适用场景：

- 当输入数据范围很大时，等价类划分帮助测试者选择具有代表性的测试数据，避免不必要的重复测试。

## 边界值分析法

边界值分析法（Boundary Value Analysis）是等价类划分的一个扩展，着重于测试输入数据的边界条件，因为边界值往往是程序出错的地方。

主要步骤为：

- 对于每个等价类，选取边界值作为测试用例（包括边界值的上限和下限）。
- 对于无效等价类，也应该测试边界值附近的数据。

适用场景：

- 特别适用于存在明显边界的输入数据，例如数组的索引、数字范围、日期等。

## 决策表测试法

决策表测试法（Decision Table Testing）通过构建决策表来表达输入条件与对应行为之间的关系。它用于描述系统在不同输入条件组合下的行为，帮助识别所有的逻辑路径。

主要步骤：

- 列出所有输入条件，并考虑每种输入条件可能的状态（如"真"或"假"、"开"或"关"）。
- 通过决策表排列条件组合，并标明每个组合下的预期输出。
- 基于决策表设计测试用例。

适用场景：

- 适用于复杂的逻辑条件，如多条件决策，尤其当输入条件的组合多且复杂时。

## 状态转换测试法

状态转换测试法（State Transition Testing）用于测试系统在不同状态下的行为。系统会根据不同的输入从一个状态转移到另一个状态，因此需要根据状态转换图来设计测试用例。

主要步骤：

- 绘制系统的状态转换图，列出所有可能的状态及其之间的转换。
- 设计测试用例以覆盖状态转换过程，包括合法的状态转换和非法的状态转换。

适用场景：

- 适用于具有多种状态（如状态机系统、用户登录状态、订单处理等）的系统。

## 因果图法

因果图法（Cause-Effect Graphing）是基于逻辑关系的测试用例设计方法。通过因果图表示输入条件与输出结果之间的因果关系，进而构建测试用例。

主要步骤：

- 绘制因果图，列出系统的输入条件及其导致的输出结果。
- 从因果图中提取最小的有效测试用例集合。
- 将因果图转换为决策表，进行具体的测试设计。

适用场景：

- 适用于复杂的条件与结果之间存在因果关系的系统，尤其是需要通过多个输入条件组合来触发某个输出的场景。

## 错误推测法

错误推测法（Error Guessing）是基于测试人员的经验，通过预测系统可能出现错误的地方来设计测试用例。这种方法主要依赖于测试人员对系统的理解和直觉。

主要步骤：

- 根据历史缺陷、系统复杂性或对系统的熟悉，推测可能的缺陷区域。
- 基于推测设计测试用例，重点关注可能的错误点。

适用场景：

- 适用于经验丰富的测试人员，能够基于对系统的理解和过往经验，推测出潜在的错误区域。

## 组合测试法

组合测试法（Combinatorial Testing）通过测试输入条件的不同组合来找出可能的缺陷。这种方法适用于输入条件之间存在复杂的交互关系的系统。

主要步骤：

- 确定测试的输入条件和它们的取值范围。
- 使用数学模型（如覆盖每对条件组合的二阶组合、三阶组合）来设计最小化的测试用例集，确保覆盖所有可能的条件组合。

适用场景：

- 适用于系统中存在多个输入条件且条件之间有复杂交互关系的情况。

## 随机测试法

随机测试法（Random Testing）通过随机选择输入数据来设计测试用例。这种方法没有固定规则，完全依赖于随机选择的输入。

主要步骤：

- 随机选择输入数据，并使用这些数据作为测试用例。
- 测试通过随机选择的输入数据来验证系统是否能处理各种未预见的情况。

适用场景：

- 适用于快速探索系统，或者没有明确需求和设计文档的系统。




























































---
title: Flash

cover: https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/15_19_15_51_202410151915559.png
categories: 
  - 嵌入式
tags:
  - 外设组件
---



# 概述

![类比电脑](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/15_19_15_51_202410151915559.png)

- STM32F1系列的FLASH包含程序存储器、系统存储器和选项字节三个部分，通过闪存存储器接口（外设）可以对程序存储器和选项字节进行擦除和编程
- 读写FLASH的用途：
  - 利用程序存储器的剩余空间来保存掉电不丢失的用户数据
  - 通过在程序中编程(IAP),实现程序的自我更新
- 在线编程(ln-Circuit Programming-ICP)用于更新程序存储器的全部内容，它通过JTAG、SWD协议或系统加载程序(Bootloader)下载程序
- 在程序中编程(ln-Application Programming-IAP）可以使用微控制器支持的任一种通信接口下载程序

![命名规则](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/15_19_19_13_202410151919603.png)

| 芯片型号      | 主频 (MHz) | FLASH容量(B) | SRAM容量（ (B) |
| ------------- | ---------- | ------------ | -------------- |
| STM32F103RCT6 | 72         | 256K         | 48K            |
| STM32F103ZET6 | 72         | 512K         | 64K            |
| STM32F407ZGT6 | 168        | 1024K        | 192K           |
| STM32F429IGT6 | 180        | 1024K        | 256K           |
| STM32F76IGT6  | 216        | 1024K        | 512K           |
| STM32H7431IT6 | 480        | 2048K        | 1060K          |
| STM32F750N8H6 | 216        | 64K          | 320K           |
| STM32H750XBH6 | 400        | 128K         | 1060K          |
| STM32H750VBT6 | 480        | 128K         | 1060K          |

# 内部构成

内部FLASH主要由三部分组成：

1. 主存储器
2. 信息块
3. 闪存存储器接口寄存器。

| 闪存模块的子部分     | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| 主存储器             | 用来存放代码和数据常数 （如const类型到的数据）               |
| 信息块               | 分为两个部分：系统存储（启动程序代码）、选项字节（用户选择字节) |
| 闪存存储器接口寄存器 | 用于控制闪存读写等，是整个闪存模块的控制结构                 |

主存储器：地址范围为0x08000000~0x0807FFFF,分为256页，每页2KB(小/中容量为1K)。当BOOT0接地，系统将从0x08000000地址处开始读取代码（从主存储器启动）。

信息块：系统存储大小为2KB,用来存储ST自带的启动程序，用来串口下载代码。选项字节大小为16B,一般用于设置内存的写保护、读保护。当BOOT0接VCC,BOOT1接GND(串口下载程序)，系统运行的就是这部分代码。

![Flash内部结构](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/15_19_23_5_202410151923327.png)

## 基本结构

控制器实际上是闪存的管理员，它可以对程序存储器进行擦除和编程，也可以对选项字节进行擦除和编程，系统存储器是不能擦除和编程的。

![基本结构](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/15_19_25_3_202410151925224.png)

## 选项字节

一共16个字节，其中有一半的名称前面都带了n，也就是在写入RDP数据的时候，同时要在nRDP中写入数据的反码，如果芯片检测到这两个存储器不是反码的关系，则代表数据无效，有错误，对应的功能就不执行，这是一种安全保障措施

| 地址        | [31:24] | [23:16] | [15:8] | [7:0] |
| ----------- | ------- | ------- | ------ | ----- |
| 0x1FFF F800 | nUSER   | USER    | nRDP   | RDP   |
| 0x1FFF F804 | nData1  | Data1   | nData0 | Datao |
| 0x1FFF F808 | nWRP1   | WRP1    | nWRPO  | WRPO  |
| 0x1FFF F80C | nWRP3   | WRP3    | nWRP2  | WRP2  |

- RDP:写入RDPRT键(OxO00000A5)后解除读保护
- USER：配置硬件看门狗和进入停机/待机模式是否产生复位
- Data0/1:用户可自定义使用
- WRP0/1/2/3:配置写保护，每一个位对应保护4个存储页（中容量)

### 选项字节编程

- 检查FLASH SR的BSY位，以确认没有其他正在进行的编程操作
- 解锁FLASH CR的OPTWRE位
- 设置FLASH CR的OPTPG位为1
- 写入要编程的半字到指定的地址
- 等待BSY位变为0
- 读出写入的地址并验证数据

### 选项字节擦除

- 检查FLASH SR的BSY位，以确认没有其他正在进行的闪存操作
- 解锁FLASH CR的OPTWRE位
- 设置FLASH_CR的OPTER位为1
- 设置FLASH CR的STRT位为1
- 等待BSY位变为0
- 读出被擦除的选择字节并做验证

### 器件电子签名

电子签名存放在闪存存储器模块的系统存储区域，包含的芯片识别信息在出厂时编写，不可更改，使用指针读指定地址下的存储器可获取电子签名

闪存容量寄存器：

- 基地址：0x1FFFF7E0
- 大小：16位

产品唯一身份标识寄存器：

- 基地址：0x1FFFF7E8
- 大小：96位

# 读写过程

对FLASH的核心操作就是==读==和==写==。

> [!IMPORTANT]
>
> FLASH的物理特性：只能写0，不能写1，写1靠擦除。

## FLASH解锁

FPEC共有三个键值：

- RDPRT键=0x000000A5
- KEY1 = 0x45670123
- KEY2 = 0xCDEF89AB

解锁：

- 复位后，FPEC被保护，不能写入FLASH_CR，所以说是默认锁着
- 在FLASH_KEYR先写入KEY1，再写入KEY2，解锁，这里有两道锁
- 错误的操作序列会在下次复位前索斯FPEC和FLASH_CR

加锁：

- 设置FLASH_CR中的LOCK位所著FPEC和FLASH_CR

## 使用指针访问存储器

```c
// 使用指针读指定地址下的存储器：
uint16 t Data *((__IO uint16_t *)(0x08000000));
// 使用指针写指定地址下的存储器：
*((__IO uint16_t*)(0x0800000))=0x1234;
// 其中：
#define __IO volatile
```

STM32内部的存储器是直接挂载在总线上的，所以这时再读写某个存储器就非常简单了，可以直接使用指针就可以访问

在数据类型前面加上volatile是一个安全保障措施，就是防止编译器优化

keil编译器在默认情况下是最低优化等级，加不加volatile都没有影响，如果提高优化等级，那么程序可能会出现一定的问题

假设想用变量计数空循环的方式实现延时函数，那么在编译器优化的时候可能会觉得延时函数没有作用，可能会直接将这段代码优化掉，加上volatile之后会告诉编译器，无论对这个变量做什么，都不能优化，需要原封不动的去执行。

此外，编译器还会利用缓存来加速代码，最常见的优化方式就是把变量转移到高速缓存里来，在stm32内核里，有一个类似缓存的工作组寄存器，这些寄存器的访问速度最快，先将变量放到缓存中，需要读写的时候直接访问缓存即可，用完之后再写回内存。但是如果程序中有多个线程，比如中断函数，在中断函数里，改变某个原始变量，缓存可能并不知道变量已经改变，下次读写的时候，程序还看缓存中的变量，就会造成数据更改不同步的问题，这时，解决的方法是读取变量定义前面加上volatile，告诉编译器这个变量是易变的，每次读取都应该从内存中读取，而不是从缓存中读取

## 闪存的读取

直接在通用地址空间直接寻址，任何32位数据的读操作都能访问闪存模块的内容并得到相对应的据。

![image-20241015194108190](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/15_19_41_8_202410151941280.png)

CPU运行速度比FLASH快得多，STM32F103的FLASH最快访问速度≤24MHz,CPU频率超过这个速度，得加入等待时间，否则读写FLASH可能出错，导致死机等情况。

| 频率范围               | 等待周期数(LATENCY) |
| ---------------------- | ------------------- |
| 0< SYSCLK <2 24MHz     | 0个等待周期         |
| 24MHz < SYSCLK ≤ 48MHz | 1个等待周期         |
| 48MHz< SYSCLK≤72MHz    | 2个等待周期         |

正确设置好等待周期后，利用指读取据。

从地址addr,读取数据（字节为8位，半字为16位，字为32位）

```c
/*读取一个字节数据*/
data = *(volatile uint8 t *)addr;
/*读取一个半字数据*/
data *(volatile uint16 t *)addr;
/*读取一个字据*/
data *(volatile uint32 t )addr;
// 将addr强制转换为uintx_t指针，然后取该指针所指向地址的值，即可获得addr地址的据。
// 注意：在进行写或擦除操作时，不能进行代码或据的读取操作。
// 写操作：*(volatile uint16t)addr=data?并不全是
```

## 闪存的写入

闪存编程是由FPEC(闪存编程和擦除控制器)模块处理的。

写操作有四步：*==解锁→擦除→写数据→上锁==*

![闪存的写入](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/15_19_45_39_202410151945445.png)

### 编程过程

![编程过程](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/15_19_47_24_202410151947042.png)

1. 首先读取LOCK位，看看芯片锁没锁
2. Lock = 1代表被锁，执行解锁过程，在KEYR寄存器中先写入KEY1，再写入KEY2，在库函数中没有判断过程，不管锁没锁都执行解锁操作
3. 首先置控制寄存器中的STRT 为1，STRT为1是触发条件，这个时候芯片才能开始工作。之后将PG位（programming编程）置为1，代表进行的操作是进行写入
4. 在指定的地址写入半字（16位），这时就可以使用指针写入数据，这里只能以半字写入
5. 擦除开始后，程序需要等待一段时间，判断状态寄存器的BSY是否为1，BSY代表芯片是否处于忙状态，BSY为1代表芯片忙

### 闪存页擦除过程

![闪存页擦除过程](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/15_19_48_11_202410151948099.png)

1. 首先读取LOCK位，看看芯片锁没锁
2. Lock = 1代表被锁，执行解锁过程，在KEYR寄存器中先写入KEY1，再写入KEY2，在库函数中没有判断过程，不管锁没锁都执行解锁操作
3. 首先置控制寄存器中的STRT 为1，STRT为1是触发条件，这个时候芯片才能开始工作。之后将PER（page     erase页擦除）置为1，代表进行的操作是页擦除，在AR地址寄存器中写入需要擦除的页地址
4. 擦除开始后，程序需要等待一段时间，判断状态寄存器的BSY是否为1，BSY代表芯片是否处于忙状态，BSY为1代表芯片忙

### 闪存全擦除过程

![闪存全擦除过程](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/15_19_48_59_202410151948041.png)

1. 首先读取LOCK位，看看芯片锁没锁
2. Lock = 1代表被锁，执行解锁过程，在KEYR寄存器中先写入KEY1，再写入KEY2，在库函数中没有判断过程，不管锁没锁都执行解锁操作
3. 首先置控制寄存器中的STRT 为1，STRT为1是触发条件，这个时候芯片才能开始工作。之后将MER（mass     erase全擦除）置为1，代表进行的操作是全擦除
4. 擦除开始后，程序需要等待一段时间，判断状态寄存器的BSY是否为1，BSY代表芯片是否处于忙状态，BSY为1代表芯片忙

### 闪存的擦除和写入

![闪存的擦除和写入](https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/10/15_19_50_12_202410151950142.png)










































































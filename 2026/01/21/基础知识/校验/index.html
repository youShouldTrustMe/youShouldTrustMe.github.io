<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>校验 | 🍭​你要信我啊の博客​</title><meta name="author" content="ryf"><meta name="copyright" content="ryf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="校验和 (Checksum)参考链接CheckSum算法–又名累加和校验算法 - 皮卡成球 - 博客园 原理及步骤**校验和（Checksum）**是网络协议使用的数据错误检测方法，并且被认为比LRC（纵向冗余校验，Longitudinal Redundancy Check，LRC），VRC和CRC（循环冗余校验（Cyclic Redundancy Codes，CRC））更可靠。此方法在发送方使用">
<meta property="og:type" content="article">
<meta property="og:title" content="校验">
<meta property="og:url" content="https://youshouldtrustme.github.io/2026/01/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%A0%A1%E9%AA%8C/index.html">
<meta property="og:site_name" content="🍭​你要信我啊の博客​">
<meta property="og:description" content="校验和 (Checksum)参考链接CheckSum算法–又名累加和校验算法 - 皮卡成球 - 博客园 原理及步骤**校验和（Checksum）**是网络协议使用的数据错误检测方法，并且被认为比LRC（纵向冗余校验，Longitudinal Redundancy Check，LRC），VRC和CRC（循环冗余校验（Cyclic Redundancy Codes，CRC））更可靠。此方法在发送方使用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/20_15_29_28_202411201529004.png">
<meta property="article:published_time" content="2026-01-21T02:07:02.599Z">
<meta property="article:modified_time" content="2026-01-21T02:07:02.599Z">
<meta property="article:author" content="ryf">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/20_15_29_28_202411201529004.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "校验",
  "url": "https://youshouldtrustme.github.io/2026/01/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%A0%A1%E9%AA%8C/",
  "image": "https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/20_15_29_28_202411201529004.png",
  "datePublished": "2026-01-21T02:07:02.599Z",
  "dateModified": "2026-01-21T02:07:02.599Z",
  "author": [
    {
      "@type": "Person",
      "name": "ryf",
      "url": "https://youshouldtrustme.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://youshouldtrustme.github.io/2026/01/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%A0%A1%E9%AA%8C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '校验',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/index.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-a-jiafangzijianzhu"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-a-folderyellow"></use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei-"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-a-07biaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guanyuwomen"></use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/friends/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie"></use></svg><span class="menu_word" style="font-size:17px"> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/20_15_29_28_202411201529004.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">🍭​你要信我啊の博客​</span></a><a class="nav-page-title" href="/"><span class="site-name">校验</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-a-jiafangzijianzhu"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-a-folderyellow"></use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei-"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-a-07biaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guanyuwomen"></use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/friends/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie"></use></svg><span class="menu_word" style="font-size:17px"> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">校验</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-21T02:07:02.599Z" title="发表于 2026-01-21 02:07:02">2026-01-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-21T02:07:02.599Z" title="更新于 2026-01-21 02:07:02">2026-01-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="校验和-Checksum"><a href="#校验和-Checksum" class="headerlink" title="校验和 (Checksum)"></a>校验和 (Checksum)</h1><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pikacq/p/18408076">CheckSum算法–又名累加和校验算法 - 皮卡成球 - 博客园</a></p>
<h2 id="原理及步骤"><a href="#原理及步骤" class="headerlink" title="原理及步骤"></a>原理及步骤</h2><p>**校验和（Checksum）**是网络协议使用的数据错误检测方法，并且被认为比LRC（纵向冗余校验，Longitudinal Redundancy Check，LRC），VRC和CRC（循环冗余校验（Cyclic Redundancy Codes，CRC））更可靠。此方法在发送方使用校验和生成器，在接收方使用校验和校验器。</p>
<p><strong>累加和校验算法的实现</strong></p>
<blockquote>
<p><em><code>发送</code>方</em>：对要数据累加，得到一个数据和，对和求反，即得到我们的校验值。然后把要发的数据和这个校验值一起发送给接收方。</p>
<p><em><code>接受</code>方</em>：对接收的数据（包括校验和）进行累加，然后加1，如果得到0，那么说明数据没有出现传输错误。</p>
<blockquote>
<p>注意，此处发送方和接收方用于保存累加结果的类型一定要一致，否则加1就无法实现溢出从而无法得到0，校验就会无效。</p>
</blockquote>
</blockquote>
<p><strong>步骤</strong>：</p>
<ol>
<li>校验数据以16bit为单位进行累加求和，校验数据需为偶字节数（不然无法以16bit为累加单位），奇字节数末尾填充0变为偶字节数；</li>
<li>累加和超过16bit，产生进位，将进位当作高16bit，其他数为低16bit，进行相加；</li>
<li>循环步骤2，直到没有进位产生为止，得到sum值</li>
<li>累加和取反得到校验和，即checksum值，存入数据的checksum字段即可。</li>
</ol>
<blockquote>
<p>[!important]</p>
<p>CheckSum取反主要原理是：</p>
<p>&#x3D;&#x3D;原码+反码+1 &#x3D; 0&#x3D;&#x3D;</p>
</blockquote>
<h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><blockquote>
<p>八位保存累加和：</p>
<p>需要发送数据(8bit 2进制)： 10101001 00111001 00001010</p>
<ol>
<li><code>奇字节补0:10101001 00111001 00001010 00000000</code></li>
<li><code>10101001 + 00111001 + 00001010 + 00000000 = 11101100(sum值)</code></li>
<li><code>~11101100 = 00010011(checksum值)</code></li>
<li>所以发送的数据就是： 10101001 00111001 00001010 00010011</li>
<li>接收方接收到的数据是： 10101001 00111001 00001010 00010011</li>
<li><code>10101001 + 00111001 + 00001010 + 00010011 = 11111111(sum值)</code></li>
<li><code>~11111111 = 00000000(结果是0，校验完成，没有错误)</code></li>
</ol>
</blockquote>
<blockquote>
<p>十六位保存累加和：</p>
<p>需要发送的数据(16bit 16进制)： 1234 003c 1c46 4000 4006 ‘<strong>checksum</strong>‘ ac00 0a63 ac10 0a0c</p>
<p>根据原始数据计算出checksum（至于checksum段的位置，我想可能是自定义的，在哪都不影响）， 才是发送出去的完成数据</p>
<ol>
<li><code>先将checksum段置0，1234 003c 1c46 4000 4006 0000 ac00 0a63 ac10 0a0c</code></li>
<li><code>sum = 1234 + 003c + 1c46 + 4000 + 4006 + 0000 + ac00 + 0a63 + ac10 + 0a0c = 21b3b (进位加到低16bit末尾)</code></li>
<li><code>checksum = ~1b3d = e4c2(即checksum值)</code></li>
<li>所以发送方发送的数据为：1234 003c 1c46 4000 4006 e4c2 ac00 0a63 ac10 0a0c（补全 cehcksum字段）</li>
<li><code>sum = 1234 + 003c + 1c46 + 4000 + 4006 + e4c2 + ac00 + 0a63 + ac10 + 0a0c = 2fffd(再回加)</code></li>
<li><code>checksum = ~ffff=0000</code></li>
<li>接收方checksum&#x3D;0，校验成功</li>
</ol>
</blockquote>
<p><strong>示例代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">TX_CheckSum</span><span class="params">(<span class="type">uint8_t</span> *buf, <span class="type">uint8_t</span> len)</span> <span class="comment">//buf为数组，len为数组长度</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">uint8_t</span> i, ret = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret += *(buf++);</span><br><span class="line">    &#125;</span><br><span class="line">     ret = ~ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">RX_CheckSum</span><span class="params">(<span class="type">uint8_t</span> *buf, <span class="type">uint8_t</span> len)</span> <span class="comment">//buf为数组，len为数组长度</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">uint8_t</span> i, ret = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret += *(buf++);</span><br><span class="line">    &#125;</span><br><span class="line">     ret = ret;</span><br><span class="line">    <span class="keyword">return</span> ret+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="循环冗余校验-CRC"><a href="#循环冗余校验-CRC" class="headerlink" title="循环冗余校验 (CRC)"></a>循环冗余校验 (CRC)</h1><h2 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/CRC.html">什么是CRC（Cyclic Redundancy Check）？如何解决CRC错误？ - 华为 (huawei.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97">循环冗余校验 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>循环冗余校验CRC（Cyclic Redundancy Check）是数据通信领域常用的一种数据传输检错技术。通过在发送端对数据按照某种算法计算出校验码，并将得到的校验码附在数据帧的后面，一起发送到接收端。接收端对收到的数据和校验码按照相同算法进行验证，以此判断接收到的数据是否正确、完整。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>CRC的思想就是先在要发送的K比特长度的数据后面附加一个R比特长度的校验码，然后生成一个新帧发送给接收端。接收端接收到新帧后，根据收到的数据和校验码来验证接收到的数据是否正确。</p>
<p><img src="https://download.huawei.com/mdl/image/download?uuid=318d36eb8dc64b1dabc6626dfc958b91" alt="数据+校验码示例"></p>
<p>当然，&#x3D;&#x3D;这个附加的校验码不是随意添加的&#x3D;&#x3D;，要使所生成的新帧能与发送端和接收端共同选定的某个特定数整除（“模2除法”）。接收端把接收到的新帧除以这个选定的除数。因为在发送数据帧之前就已通过附加一个数，做了“去余”处理（也就已经能整除了），所以结果应该是没有余数。如果有余数，则表明该帧在传输过程中出现了差错。</p>
<blockquote>
<p>[!important]</p>
<p>原始数据 + 余数 &#x3D; 2的倍数</p>
<p>所以说如果接收到的数据对2取余不为0，说明传输有问题</p>
</blockquote>
<p>在K比特数据后面再拼接R比特的校验码，整个编码长度为N比特，这种编码也叫&#x3D;&#x3D;(N,K)码&#x3D;&#x3D;。对于一个给定的(N,K)码，可以证明存在一个最高次幂为N-K&#x3D;R的多项式g(x)，根据g(x)可以生成R比特的校验码。其算法是以GF(2)多项式算术为数学基础的。</p>
<blockquote>
<p>[!TIP]</p>
<p>CRC 是一种基于多项式的错误检测方法。数据被视为一个多项式，通过特定的生成多项式进行除法运算，余数即为 CRC 值。</p>
<p>&#x3D;&#x3D;也就是说除数是一个多项式的系数组成的数值，将原始数据（被除数）+ 余数 &#x3D; 多项式系数的倍数&#x3D;&#x3D;</p>
<p>CRC是基于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E5%9F%9F">有限域</a><strong>GF(2)</strong>（即<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%99%A4%E4%BB%A52">除以2</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%90%8C%E4%BD%99">同余</a>）的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%8E%AF">多项式环</a>。简单的来说，就是所有系数都为0或1（又叫做二进制）的多项式系数的集合，并且集合对于所有的代数操作都是封闭的。例如：<br>$$<br>{\displaystyle (x^{3}+x)+(x+1)&#x3D;x^{3}+2x+1\equiv x^{3}+1}<br>$$<br>2会变成0，因为对系数的加法运算都会再取2的模数。乘法也是类似的：<br>$$<br>{\displaystyle (x^{2}+x)(x+1)&#x3D;x^{3}+2x^{2}+x\equiv x^{3}+x}<br>$$<br>同样可以对多项式作除法并且得到商和余数。例如，如果用$x^3 + x^2 + x$除以$x + 1$。会得到：<br>$$<br>{\displaystyle {\frac {(x^{3}+x^{2}+x)}{(x+1)}}&#x3D;(x^{2}+1)-{\frac {1}{(x+1)}}}<br>$$<br>也就是说：<br>$$<br>{\displaystyle (x^{3}+x^{2}+x)&#x3D;(x^{2}+1)(x+1)-1}<br>$$<br>等价于：<br>$$<br>{\displaystyle (x^{2}+x+1)x&#x3D;(x^{2}+1)(x+1)-1}<br>$$<br>这里除法得到了商$x^2 + 1$和余数-1，因为是奇数所以最后一位是1。</p>
<p>字符串中的每一位其实就对应了这样类型的多项式的系数。为了得到CRC，首先将其乘以$x^n$，这里$n$是一个固定多项式的**<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%9A%E9%A0%85%E5%BC%8F%E7%9A%84%E9%9A%8E&action=edit&redlink=1">阶数</a>**，然后再将其除以这个固定的多项式，余数的系数就是CRC。</p>
<p>在上面的等式中，$x^2+x+1$表示了本来的信息位是<code>111</code>, $x+1$是所谓的<strong>钥匙</strong>，而余数1（也就是$x^0$）就是CRC，key的最高次为1,所以将原来的信息乘上$x^1$来得到$x^3+x^2+x$，也可视为原来的信息位补1个零成为<code>1110</code>。</p>
<p>一般来说，其形式为：<br>$$<br>{\displaystyle M(x)\cdot x^{n}&#x3D;Q(x)\cdot K(x)-R(x)}<br>$$<br>这里M(x)是原始的信息多项式。K(x)是$n$阶的“钥匙”多项式。$𝑀(𝑥)⋅𝑥^𝑛$表示了将原始信息后面加上$n$个0。$R(x)$是余数多项式，即是&#x3D;&#x3D;CRC“校验和”&#x3D;&#x3D;。在通信中，发送者在原始的信息数据$M$后附加上$𝑛$位的$R$（替换本来附加的0）再发送。接收者收到M和R后，检查$𝑀(𝑥)⋅𝑥^𝑛+𝑅(𝑥)$是否能被$𝐾(𝑥)$整除。如果是，那么接收者认为该信息是正确的。值得注意的是$𝑀(𝑥)⋅𝑥^𝑛+𝑅(𝑥)$就是发送者所想要发送的数据。这个串又叫做<em>codeword</em>.</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">多项式</th>
<th align="center">表示法：正常或者翻转</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CRC-1</td>
<td align="center">${\displaystyle x+1}$（用途：硬件，也称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E4%BD%8D">奇偶校验位</a>)</td>
<td align="center">0x1 or 0x1 (0x1)</td>
</tr>
<tr>
<td align="center">CRC-5-CCITT</td>
<td align="center">${\displaystyle x^{5}+x^{3}+x+1}$（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ITU">ITU</a> G.704标准)</td>
<td align="center">0xB（0x??）</td>
</tr>
<tr>
<td align="center">CRC-5-USB</td>
<td align="center">${\displaystyle x^{5}+x^{2}+1}$（用途：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/USB">USB</a>信令包)</td>
<td align="center">0x5 or 0x14 (0x9)</td>
</tr>
<tr>
<td align="center">CRC-7</td>
<td align="center">${\displaystyle x^{7}+x^{3}+1}$（用途：通信系统)</td>
<td align="center">0x9 or 0x48 (0x11)</td>
</tr>
<tr>
<td align="center">CRC-8-ATM</td>
<td align="center">${\displaystyle x^{8}+x^{2}+x+1}$（用途：ATM HEC, PMBUS （参见SMBUS org[<a target="_blank" rel="noopener" href="http://smbus.org/faq/crc8Applet.htm">1]</a> （<a target="_blank" rel="noopener" href="https://web.archive.org/web/20220328104435/http://smbus.org/faq/crc8Applet.htm">页面存档备份</a>，存于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%A1%A3%E6%A1%88%E9%A6%86">互联网档案馆</a>））)</td>
<td align="center">0x7或0xE0 (0xC1)</td>
</tr>
<tr>
<td align="center">CRC-8-<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CCITT">CCITT</a></td>
<td align="center">${\displaystyle x^{8}+x^{7}+x^{3}+x^{2}+1}$（用途：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/1-Wire">1-Wire</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B8%BD%E7%B7%9A">总线</a>)</td>
<td align="center">0x8D</td>
</tr>
<tr>
<td align="center">CRC-8-<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Dallas_Semiconductor&action=edit&redlink=1">Dallas</a>&#x2F;<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Maxim_IC&action=edit&redlink=1">Maxim</a></td>
<td align="center">${\displaystyle x^{8}+x^{5}+x^{4}+1}$（用途：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/1-Wire">1-Wire</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Bus">bus</a>)</td>
<td align="center">0x31或0x8C</td>
</tr>
<tr>
<td align="center">CRC-8</td>
<td align="center">${\displaystyle x^{8}+x^{7}+x^{6}+x^{4}+x^{2}+1}$</td>
<td align="center">0xD5（0x??）</td>
</tr>
<tr>
<td align="center">CRC-10</td>
<td align="center">${\displaystyle x^{10}+x^{9}+x^{5}+x^{4}+x+1}$</td>
<td align="center">0x233（0x????）</td>
</tr>
<tr>
<td align="center">CRC-12</td>
<td align="center">${\displaystyle x^{12}+x^{11}+x^{3}+x^{2}+x+1}$（用途：通信系统)</td>
<td align="center">0x80F或0xF01 (0xE03)</td>
</tr>
<tr>
<td align="center">CRC-16-Fletcher</td>
<td align="center">参见<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Fletcher%27s_checksum&action=edit&redlink=1">Fletcher’s checksum</a></td>
<td align="center">用于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Adler-32">Adler-32</a> A &amp; B CRC</td>
</tr>
<tr>
<td align="center">CRC-16-CCITT</td>
<td align="center">${\displaystyle x^{16}+x^{12}+x^{5}+1}$（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=X25&action=edit&redlink=1">X25</a>, <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=V.41&action=edit&redlink=1">V.41</a>, <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Bluetooth">Bluetooth</a>, <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PPP">PPP</a>, <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=IrDA&action=edit&redlink=1">IrDA</a>)</td>
<td align="center">0x1021或0x8408 (0x0811)</td>
</tr>
<tr>
<td align="center">CRC-16-<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IBM">IBM</a></td>
<td align="center">${\displaystyle x^{16}+x^{15}+x^{2}+1}$（用途：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Modbus">Modbus）</a></td>
<td align="center">0x8005或0xA001 (0x4003)</td>
</tr>
<tr>
<td align="center">CRC-16-<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/BBS">BBS</a></td>
<td align="center">${\displaystyle x^{16}+x^{15}+x^{10}+x^{3}}+1$（用途：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=XMODEM&action=edit&redlink=1">XMODEM</a>协议)</td>
<td align="center">0x8408（0x????）</td>
</tr>
<tr>
<td align="center">CRC-32-Adler</td>
<td align="center">参见<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Adler-32">Adler-32</a></td>
<td align="center">参见<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Adler-32">Adler-32</a></td>
</tr>
<tr>
<td align="center">CRC-32-MPEG2</td>
<td align="center">参见<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_802.3">IEEE 802.3</a></td>
<td align="center">参见<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_802.3">IEEE 802.3</a></td>
</tr>
<tr>
<td align="center">CRC-32-<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_802.3">IEEE 802.3</a></td>
<td align="center">${\displaystyle x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^{8}+x^{7}+x^{5}+x^{4}+x^{2}+x+1}$</td>
<td align="center">0x04C11DB7或0xEDB88320 (0xDB710641)</td>
</tr>
<tr>
<td align="center">CRC-32C(Castagnoli)</td>
<td align="center">${\displaystyle x^{32}+x^{28}+x^{27}+x^{26}+x^{25}+x^{23}+x^{22}+x^{20}+x^{19}+x^{18}+x^{14}+x^{13}+x^{11}+x^{10}+x^{9}+x^{8}+x^{6}+1}$</td>
<td align="center">0x1EDC6F41或0x82F63B78 (0x05EC76F1)</td>
</tr>
<tr>
<td align="center">CRC-64-ISO</td>
<td align="center">${\displaystyle x^{64}+x^{4}+x^{3}+x+1}$ （用途: ISO 3309)</td>
<td align="center">0x000000000000001B或0xD800000000000000 (0xB000000000000001)</td>
</tr>
<tr>
<td align="center">CRC-64-<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Ecma_International">ECMA</a>-182</td>
<td align="center">${\displaystyle x^{64}+x^{62}+x^{57}+x^{55}+x^{54}+x^{53}+x^{52}+x^{47}+x^{46}+x^{45}+x^{40}+x^{39}+x^{38}+x^{37}+x^{35}+x^{33}+x^{32}}+$ ${\displaystyle +x^{31}+x^{29}+x^{27}+x^{24}+x^{23}+x^{22}+x^{21}+x^{19}+x^{17}+x^{13}+x^{12}+x^{10}+x^{9}+x^{7}+x^{4}+x+1}$（参见<a target="_blank" rel="noopener" href="http://www.ecma-international.org/publications/standards/Ecma-182.htm">ECMA-182</a> （<a target="_blank" rel="noopener" href="https://web.archive.org/web/20200731173949/http://www.ecma-international.org/publications/standards/Ecma-182.htm">页面存档备份</a>，存于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%A1%A3%E6%A1%88%E9%A6%86">互联网档案馆</a>） p.63)</td>
<td align="center">0x42F0E1EBA9EA3693或0xC96C5795D7870F42 (0x92D8AF2BAF0E1E85)</td>
</tr>
<tr>
<td align="center">CRC-128</td>
<td align="center">IEEE-ITU标准。被<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MD5">MD5</a> &amp; <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SHA-1">SHA-1</a>取代</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">CRC-160</td>
<td align="center">IEEE-ITU标准。被<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MD5">MD5</a> &amp; <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SHA-1">SHA-1</a>取代</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>这些多项式的值便是&#x3D;&#x3D;模2除法的除数&#x3D;&#x3D;。而根据这个除数获得校验码并进行校验的原理可以分为以下几个步骤：</p>
<ol>
<li>发送端、接收端在通信前，约定好除数P，也就是前面说的多项式的值。P应该是R+1位长度；</li>
<li>发送端首先在原来的K位数据后面加R个0，相当于原来的数据左移了R位；</li>
<li>然后进行模2除法运算（其实就是异或XOR运算），将加0之后的K+R位的数除以P，循环计算，直到余数的阶数小于R，这个余数就是附加的校验码，如果长度不足R位需要在前面加0补齐；</li>
<li>发送端将R位校验码附加在原数据后面发送给接收方；</li>
<li>接收方接收到数据后，将数据以模2除法方式除以除数P。如果没有余数，说明在传输过程中没有出现错误，否则说明有错误。</li>
</ol>
<h2 id="栗子-1"><a href="#栗子-1" class="headerlink" title="栗子"></a>栗子</h2><p>以g(x)为$CRC-4&#x3D;x^{4}+x+1$为例，此时除数P&#x3D;10011。假设源数据M为10110011。</p>
<p>在发送端将M左移4位，然后除以P。</p>
<p><img src="https://download.huawei.com/mdl/image/download?uuid=e0ffb1aa886f489e8b0c8d33f60594b7" alt="发送端CRC计算示例"></p>
<p>&#x3D;&#x3D;计算得到的余数就是<strong>0100</strong>，也就是CRC校验码&#x3D;&#x3D;。将<strong>0100</strong>附加到原始数据帧10110011后，组成新帧10110011<strong>0100</strong>发送给接收端。接收端接收到该帧后，会用该帧去除以上面选定的除数P，验证余数是否为0，如果为0，则表示数据在传输过程中没有出现差错。</p>
<p><img src="https://download.huawei.com/mdl/image/download?uuid=7a26a1a18fcf4b9da540df869b56a15c" alt="接收端CRC校验示例"></p>
<p><strong>示例代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">crc32</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">size_t</span> length)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> crc = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        crc ^= data[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (crc &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                crc = (crc &gt;&gt; <span class="number">1</span>) ^ <span class="number">0xEDB88320</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                crc &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ~crc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> crc = crc32(data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CRC32: %08X\n&quot;</span>, crc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!IMPORTANT]</p>
<p>异或操作：</p>
<p>当对一个数据进行两次异或时就可以得到数据本身</p>
</blockquote>
<h1 id="哈希校验-Hash-Check"><a href="#哈希校验-Hash-Check" class="headerlink" title="哈希校验 (Hash Check)"></a>哈希校验 (Hash Check)</h1><h2 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhuoxiuwu/article/details/103070144">【数据加解密】MD5检验算法的原理及实现_md5校验原理-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37257569">MD5算法 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011583927/article/details/80905740">SHA256算法原理详解-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SHA-2">SHA-2 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
<h2 id="MD5摘要算法"><a href="#MD5摘要算法" class="headerlink" title="MD5摘要算法"></a>MD5摘要算法</h2><p>我们首先假设有一个 b 个bit的数据作为输入，然后我们希望根据某种规则计算出它的信息摘要。这里b是任意大小的数据，也不需要是8bit的倍数。 我们假设数据的字节如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_0 m_1 …  m_&#123;b-1&#125;</span><br></pre></td></tr></table></figure>

<p>现在要生成MD5码要经过以下步骤:</p>
<ol>
<li><p>填充位</p>
<p>输入数据首先被”填充”(拓展)，以保证它的长度%512 &#x3D; 448。 在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。</p>
</li>
<li><p>追加消息长度信息</p>
<p>追加一个64位的数据，该数据表示b的长度（步骤1填充之后的），如果b的长度大于$2^{64}$，那么只使用该长度值二进制表示的低64位（比如如果长度是0x82a89c7434,则只使用0xa89c7434）。</p>
<p>追加长度信息后，此时数据的长度是 512的倍数，并且也是16的倍数。经过这两步的处理，信息的位长&#x3D;N * 512+448+64&#x3D;(N+1）*512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求。</p>
</li>
<li><p>初始化MD buffer</p>
<p>创建一个128位的 buffer (A、B、C、D)用于计算消息摘要。这里的A、B、C、D都是32位寄存器。这些寄存器初始化为以下十六进制低阶字节的值<br> word A: 01 23 45 67<br> word B: 89 ab cd ef<br> word C: fe dc ba 98<br> word D: 76 54 32 10<br>在程序中表示为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var <span class="type">int</span> h0 := <span class="number">0x67452301</span></span><br><span class="line">var <span class="type">int</span> h1 := <span class="number">0xEFCDAB89</span></span><br><span class="line">var <span class="type">int</span> h2 := <span class="number">0x98BADCFE</span></span><br><span class="line">var <span class="type">int</span> h3 := <span class="number">0x10325476</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>处理分组数据</p>
<p>将步骤2处理完的数据的一包（512bit）数据划分为16组，每组数据为32位（$32 \times 16 &#x3D; 512$），处理过程如下：</p>
<ol>
<li>主循环有四轮（MD4只有三轮），每轮循环执行16次非线性函数（循环16次遍历完成一包数据）。</li>
<li>每次操作对a、b、c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，再加上划分好的一组数据和一个常数。最后将所得结果向左循环左移一个不定的数，并加上a、b、c或d中之一。最后用该结果取代a、b、c或d中之一。</li>
</ol>
<p>以下是每次操作中用到的四个非线性函数（每轮一个）<br>**F(X,Y,Z) **&#x3D; ( X &amp; Y ) | ( ( ~X ) &amp; Z )<br><strong>G(X,Y,Z)</strong> &#x3D; ( X &amp; Z ) | ( Y &amp; ( ~Z ) )<br>**H(X,Y,Z) **&#x3D; X^ Y ^ Z<br>**I(X,Y,Z) **&#x3D; Y^( X | ( ~Z ) )</p>
<blockquote>
<p>[!tip]</p>
<p>其中，&amp;是与（And），|是或（Or），~是非（Not），^是异或（Xor</p>
<p>如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。</p>
<p>F是一个逐位运算的函数。即，如果X，那么Y，否则Z。函数H是逐位奇偶操作符。</p>
</blockquote>
<p>假设M[j]表示加密数据的第j组（从0到15），常数$ti$是$4294967296*abs( sin(i))$的整数部分，i 取值从1到64，单位是弧度。（$4294967296&#x3D;2^{32}$）</p>
<p>现定义<br>$$<br>FF(a ,b ,c ,d ,Mj ,s ,ti) :操作为 a &#x3D; b + ( (a + F(b,c,d) + Mj + ti) &lt;&lt; s)\<br>GG(a ,b ,c ,d ,Mj ,s ,ti) :操作为 a &#x3D; b + ( (a + G(b,c,d) + Mj + ti) &lt;&lt; s)\<br>HH(a ,b ,c ,d ,Mj ,s ,ti) :操作为 a &#x3D; b + ( (a + H(b,c,d) + Mj + ti) &lt;&lt; s)\<br>II(a ,b ,c ,d ,Mj ,s ,ti) :操作为 a &#x3D; b + ( (a + I(b,c,d) + Mj + ti) &lt;&lt; s)\<br>$$</p>
<blockquote>
<p>[!tip]</p>
<p>需要注意的是：这里的&lt;&lt;是循环左移</p>
</blockquote>
<p>那么四轮六十四步开始（一轮十六步）：</p>
<ol>
<li><p>第一轮：<br>$$<br>FF(a ,b ,c ,d ,M[0],7 ,0xd76aa478 )\<br>FF(d ,a ,b ,c ,M[1] ,12 ,0xe8c7b756 )\<br>FF(c ,d ,a ,b ,M[2] ,17 ,0x242070db )\<br>FF(b ,c ,d ,a ,M[3] ,22 ,0xc1bdceee )\<br>FF(a ,b ,c ,d ,M[4] ,7 ,0xf57c0faf )\<br>FF(d ,a ,b ,c ,M[5] ,12 ,0x4787c62a )\<br>FF(c ,d ,a ,b ,M[6] ,17 ,0xa8304613 )\<br>FF(b ,c ,d ,a ,M[7] ,22 ,0xfd469501)\<br>FF(a ,b ,c ,d ,M[8] ,7 ,0x698098d8 )\<br>FF(d ,a ,b ,c ,M[9] ,12 ,0x8b44f7af )\<br>FF(c ,d ,a ,b ,M[10] ,17 ,0xffff5bb1 )\<br>FF(b ,c ,d ,a ,M[11] ,22 ,0x895cd7be )\<br>FF(a ,b ,c ,d ,M[12] ,7 ,0x6b901122 )\<br>FF(d ,a ,b ,c ,M[13] ,12 ,0xfd987193 )\<br>FF(c ,d ,a ,b ,M[14] ,17 ,0xa679438e )\<br>FF(b ,c ,d ,a ,M[15] ,22 ,0x49b40821 )\<br>$$</p>
</li>
<li><p>第二轮<br>$$<br>GG(a ,b ,c ,d ,M[1] ,5 ,0xf61e2562 )\<br>GG(c ,d ,a ,b ,M[11] ,14 ,0x265e5a51 )\<br>GG(b ,c ,d ,a ,M[0] ,20 ,0xe9b6c7aa )\<br>GG(a ,b ,c ,d ,M[5] ,5 ,0xd62f105d )\<br>GG(d ,a ,b ,c ,M[10] ,9 ,0x02441453 )\<br>GG(c ,d ,a ,b ,M[15] ,14 ,0xd8a1e681 )\<br>GG(b ,c ,d ,a ,M[4] ,20 ,0xe7d3fbc8 )\<br>GG(a ,b ,c ,d ,M[9] ,5 ,0x21e1cde6 )\<br>GG(d ,a ,b ,c ,M[14] ,9 ,0xc33707d6 )\<br>GG(c ,d ,a ,b ,M[3] ,14 ,0xf4d50d87 )\<br>GG(b ,c ,d ,a ,M[8] ,20 ,0x455a14ed )\<br>GG(a ,b ,c ,d ,M[13] ,5 ,0xa9e3e905 )\<br>GG(d ,a ,b ,c ,M[2] ,9 ,0xfcefa3f8 )\<br>GG(c ,d ,a ,b ,M[7] ,14 ,0x676f02d9 )\<br>GG(b ,c ,d ,a ,M[12] ,20 ,0x8d2a4c8a )<br>$$</p>
</li>
<li><p>第三轮<br>$$<br>HH(a ,b ,c ,d ,M[5] ,4 ,0xfffa3942 )\<br>HH(d ,a ,b ,c ,M[8] ,11 ,0x8771f681 )\<br>HH(c ,d ,a ,b ,M[11] ,16 ,0x6d9d6122 )\<br>HH(b ,c ,d ,a ,M[14] ,23 ,0xfde5380c )\<br>HH(a ,b ,c ,d ,M[1] ,4 ,0xa4beea44 )\<br>HH(d ,a ,b ,c ,M[4] ,11 ,0x4bdecfa9 )\<br>HH(c ,d ,a ,b ,M[7] ,16 ,0xf6bb4b60 )\<br>HH(b ,c ,d ,a ,M[10] ,23 ,0xbebfbc70 )\<br>HH(a ,b ,c ,d ,M[13] ,4 ,0x289b7ec6 )\<br>HH(d ,a ,b ,c ,M[0] ,11 ,0xeaa127fa )\<br>HH(c ,d ,a ,b ,M[3] ,16 ,0xd4ef3085 )\<br>HH(b ,c ,d ,a ,M[6] ,23 ,0x04881d05 )\<br>HH(a ,b ,c ,d ,M[9] ,4 ,0xd9d4d039 )\<br>HH(d ,a ,b ,c ,M[12] ,11 ,0xe6db99e5 )\<br>HH(c ,d ,a ,b ,M[15] ,16 ,0x1fa27cf8 )\<br>HH(b ,c ,d ,a ,M[2] ,23 ,0xc4ac5665 )\<br>$$</p>
</li>
<li><p>第四轮<br>$$<br>II(a ,b ,c ,d ,M[0] ,6 ,0xf4292244 )\<br>II(d ,a ,b ,c ,M[7] ,10 ,0x432aff97 )\<br>II(c ,d ,a ,b ,M[14] ,15 ,0xab9423a7 )\<br>II(b ,c ,d ,a ,M[5] ,21 ,0xfc93a039 )\<br>II(a ,b ,c ,d ,M[12] ,6 ,0x655b59c3 )\<br>II(d ,a ,b ,c ,M[3] ,10 ,0x8f0ccc92 )\<br>II(c ,d ,a ,b ,M[10] ,15 ,0xffeff47d )\<br>II(b ,c ,d ,a ,M[1] ,21 ,0x85845dd1 )\<br>II(a ,b ,c ,d ,M[8] ,6 ,0x6fa87e4f )\<br>II(d ,a ,b ,c ,M[15] ,10 ,0xfe2ce6e0 )\<br>II(c ,d ,a ,b ,M[6] ,15 ,0xa3014314 )\<br>II(b ,c ,d ,a ,M[13] ,21 ,0x4e0811a1 )\<br>II(a ,b ,c ,d ,M[4] ,6 ,0xf7537e82 )\<br>II(d ,a ,b ,c ,M[11] ,10 ,0xbd3af235 )\<br>II(c ,d ,a ,b ,M[2] ,15 ,0x2ad7d2bb )\<br>II(b ,c ,d ,a ,M[9] ,21 ,0xeb86d391 )<br>$$</p>
</li>
<li><p>循环过程为：</p>
<p><img src="/" alt="循环过程"></p>
</li>
<li><p>当四轮结束之后，将缓存变量的拷贝和计算结果相加：<br>$$<br>A&#x3D;A+a\<br>B&#x3D;B+b\<br>C&#x3D;C+c\<br>D&#x3D;D+d\<br>$$</p>
</li>
</ol>
</li>
<li><p>最终得到的校验值由ABCD拼成，其中A为最低位，D为最高位</p>
</li>
</ol>
<h2 id="SHA256校验"><a href="#SHA256校验" class="headerlink" title="SHA256校验"></a>SHA256校验</h2><p>SHA256是SHA-2下细分出的一种算法，SHA-2，名称来自于安全散列算法2（Secure Hash Algorithm 2）的缩写，一种密码散列函数算法标准，由美国国家安全局研发，属于SHA算法之一，是SHA-1的后继者。</p>
<p>SHA-2下又可再分为六个不同的算法标准：</p>
<ol>
<li>SHA-224</li>
<li>SHA-256</li>
<li>SHA-384</li>
<li>SHA-512</li>
<li>SHA-512&#x2F;224</li>
<li>SHA-512&#x2F;256。</li>
</ol>
<p>这些变体除了生成摘要的长度 、循环运行的次数等一些微小差异外，算法的基本结构是一致的。</p>
<p>对于任意长度的消息，SHA256都会产生一个256bit长的哈希值，称作消息摘要。这个摘要相当于是个长度为32个字节的数组，通常用一个长度为64的十六进制字符串来表示。</p>
<p>算法主要包括了：</p>
<ol>
<li>常量的初始化</li>
<li>信息的预处理</li>
<li>逻辑运算</li>
</ol>
<h3 id="常量初始化"><a href="#常量初始化" class="headerlink" title="常量初始化"></a>常量初始化</h3><p>SHA256算法中用到了8个哈希初值以及64个哈希常量</p>
<p>其中，SHA256算法的<strong>8个哈希初值</strong>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">h0 := <span class="number">0x6a09e667</span></span><br><span class="line">h1 := <span class="number">0xbb67ae85</span></span><br><span class="line">h2 := <span class="number">0x3c6ef372</span></span><br><span class="line">h3 := <span class="number">0xa54ff53a</span></span><br><span class="line">h4 := <span class="number">0x510e527f</span></span><br><span class="line">h5 := <span class="number">0x9b05688c</span></span><br><span class="line">h6 := <span class="number">0x1f83d9ab</span></span><br><span class="line">h7 := <span class="number">0x5be0cd19</span></span><br></pre></td></tr></table></figure>

<p>这些初值是对自然数中前8个质数（2,3,5,7,11,13,17,19）的平方根的小数部分取前32bit而来</p>
<p>举个例子来说，$ \sqrt{2} $小数部分约为0.414213562373095048，而$0.414213562373095048 ≈ 6 ∗ 16^{-1} + a ∗ 16 ^ {-2} + 0 ∗ 16^{-3} + …$</p>
<p>于是，质数2的平方根的小数部分取前32bit就对应出了0x6a09e667</p>
<p>在SHA256算法中，用到的64个常量如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">428</span>a2f98 <span class="number">71374491</span> b5c0fbcf e9b5dba5</span><br><span class="line"><span class="number">3956</span>c25b <span class="number">59f</span>111f1 <span class="number">923f</span>82a4 ab1c5ed5</span><br><span class="line">d807aa98 <span class="number">12835b</span>01 <span class="number">243185b</span>e <span class="number">550</span>c7dc3</span><br><span class="line"><span class="number">72b</span>e5d74 <span class="number">80</span>deb1fe <span class="number">9b</span>dc06a7 c19bf174</span><br><span class="line">e49b69c1 efbe4786 <span class="number">0f</span>c19dc6 <span class="number">240</span>ca1cc</span><br><span class="line"><span class="number">2</span>de92c6f <span class="number">4</span>a7484aa <span class="number">5</span>cb0a9dc <span class="number">76f</span>988da</span><br><span class="line"><span class="number">983e5152</span> a831c66d b00327c8 bf597fc7</span><br><span class="line">c6e00bf3 d5a79147 <span class="number">06</span>ca6351 <span class="number">14292967</span></span><br><span class="line"><span class="number">27b</span>70a85 <span class="number">2e1</span>b2138 <span class="number">4</span>d2c6dfc <span class="number">53380</span>d13</span><br><span class="line"><span class="number">650</span>a7354 <span class="number">766</span>a0abb <span class="number">81</span>c2c92e <span class="number">92722</span>c85</span><br><span class="line">a2bfe8a1 a81a664b c24b8b70 c76c51a3</span><br><span class="line">d192e819 d6990624 f40e3585 <span class="number">106</span>aa070</span><br><span class="line"><span class="number">19</span>a4c116 <span class="number">1e376</span>c08 <span class="number">2748774</span>c <span class="number">34b</span>0bcb5</span><br><span class="line"><span class="number">391</span>c0cb3 <span class="number">4</span>ed8aa4a <span class="number">5b</span>9cca4f <span class="number">682e6</span>ff3</span><br><span class="line"><span class="number">748f</span>82ee <span class="number">78</span>a5636f <span class="number">84</span>c87814 <span class="number">8</span>cc70208</span><br><span class="line"><span class="number">90b</span>efffa a4506ceb bef9a3f7 c67178f2</span><br></pre></td></tr></table></figure>

<p>和8个哈希初值类似，这些常量是对自然数中前64个质数（2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97…)的立方根的小数部分取前32bit而来。</p>
<h3 id="信息预处理"><a href="#信息预处理" class="headerlink" title="信息预处理"></a>信息预处理</h3><p>SHA256算法中的预处理就是在想要Hash的消息后面补充需要的信息，使整个消息满足指定的结构。</p>
<p>信息的预处理分为两个步骤：<code>附加填充比特</code>和<code>附加长度</code></p>
<ol>
<li><p>附加填充比特</p>
<p>&#x3D;&#x3D;在报文末尾进行填充，使报文长度在对512取模以后的余数是448。&#x3D;&#x3D;</p>
<p>填充是这样进行的：先补第一个比特为1，然后都补0，直到长度满足对512取模后余数是448。</p>
<p>需要注意的是，信息必须进行填充，也就是说，即使长度已经满足对512取模后余数是448，补位也必须要进行，这时要填充512个比特。</p>
<p>因此，填充是至少补一位，最多补512位。</p>
<blockquote>
<p>例：以信息“abc”为例显示补位的过程。</p>
<p>a,b,c对应的ASCII码分别是97,98,99</p>
<p>于是原始信息的二进制编码为：01100001 01100010 01100011</p>
<p>补位第一步，首先补一个“1” ： 0110000101100010 01100011 1</p>
<p>补位第二步,补423个“0”：01100001 01100010 01100011 10000000 00000000 … 00000000</p>
<p>补位完成后的数据如下（为了简洁用16进制表示）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">61626380</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure>

</blockquote>
<blockquote>
<p>为什么是448?</p>
<p>因为在第一步的预处理后，第二步会再附加上一个64bit的数据，用来表示原始报文的长度信息。而448+64&#x3D;512，正好拼成了一个完整的结构。</p>
</blockquote>
</li>
<li><p>附加长度值</p>
<p>附加长度值就是将原始数据（第一步填充前的消息）的长度信息补到已经进行了填充操作的消息后面。</p>
<p>SHA256用一个64位的数据来表示原始消息的长度。因此，通过SHA256计算的消息长度必须要小于$ 2^{64} $，当然绝大多数情况这足够大了。</p>
<blockquote>
<p>回到刚刚的例子，消息“abc”，3个字符，占用24个bit</p>
<p>因此，在进行了补长度的操作以后，整个消息就变成下面这样了（16进制格式）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">61626380</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000018</span></span><br></pre></td></tr></table></figure>

</blockquote>
</li>
</ol>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>SHA256散列函数中涉及的操作全部是逻辑的位运算:<br>$$<br>Ch(x,y,z)&#x3D;(x∧y)⊕(¬x∧z)\<br>Ma(x,y,z)&#x3D;(x∧y)⊕(x∧z)⊕(y∧z)\<br>Σ_0(x)&#x3D;S^2 (x)⊕S^{13}(x)⊕S^{22}(x)\<br>Σ_1 (x)&#x3D;S^6(x)⊕S^{11}(x)⊕S^{25}(x)\<br>σ_0(x)&#x3D;S^{7}(x)⊕S^{18}(x)⊕R^{3}(x)\<br>σ_1(x)&#x3D;S^{17}(x)⊕S^{19}(x)⊕R^{10}(x)<br>$$<br>其中：</p>
<table>
<thead>
<tr>
<th align="center">逻辑运算</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^</td>
<td>按位”与”</td>
</tr>
<tr>
<td align="center">¬</td>
<td>按位“补”</td>
</tr>
<tr>
<td align="center">⊕</td>
<td>按位“异或”</td>
</tr>
<tr>
<td align="center">$S^{n}$</td>
<td>循环右移n个bit</td>
</tr>
<tr>
<td align="center">$R^{n}$</td>
<td>右移n个bit</td>
</tr>
</tbody></table>
<h3 id="开始计算"><a href="#开始计算" class="headerlink" title="开始计算"></a>开始计算</h3><ol>
<li><p>首先将消息分解为512-bit大小的块</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/20_15_8_15_202411201508935.png" alt="分解"></p>
<p>假设消息M可以被分解为n个块，于是整个算法需要做的就是完成n次迭代，n次迭代的结果就是最终的哈希值，即256bit的数字摘要。</p>
<p>一个256-bit的摘要的初始值H0，经过第一个数据块进行运算，得到H1，即完成了第一次迭代，H1经过第二个数据块得到H2，……，依次处理，最后得到Hn，Hn即为最终的256-bit消息摘要。</p>
<p>将每次迭代进行的映射用$ Map(H_{i-1}) &#x3D; H_{i} $表示，于是迭代可以更形象的展示为：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/20_15_10_30_202411201510892.png" alt="循环迭代"></p>
<p>图中256-bit的<code>Hi</code>被描述8个小块，这是因为SHA256算法中的最小运算单元称为“字”（Word），一个字是32位。</p>
<p>此外，第一次迭代中，映射的初值设置为前面介绍的8个哈希初值，如下图所示：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/20_15_18_3_202411201518156.png" alt="哈希初值"></p>
</li>
<li><p>构造64个字（word）</p>
<p>对于每一块，将块分解为16个32-bit的字，记为w[0], …, w[15]</p>
<p>也就是说，前16个字直接由消息的第i个块分解得到</p>
<p>其余的字由如下迭代公式得到：<br>$$<br>W_t &#x3D;σ_1(W_{t−2})+W_{t−7}+σ_0(W_{t−15})+W_{t−16}<br>$$</p>
</li>
<li><p>进行64次循环</p>
<p>映射 $ Map(H_{i-1}) &#x3D; H_{i} $ 包含了64次加密循环，即进行64次加密循环即可完成一次迭代，</p>
<p>每次加密循环可以由下图描述：</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/20_15_23_53_202411201523511.png" alt="image-20241120152352360"></p>
<p>图中，ABCDEFGH这8个字（word）在按照一定的规则进行更新，其中深蓝色方块是事先定义好的非线性逻辑函数，上文已经做过铺垫</p>
<p>红色田字方块代表 mod $ 2^{32} $ addition，即将两个数字加在一起，如果结果大于$ 2^{32}$，你必须除以 $2^{32} $并找到余数。</p>
<p>ABCDEFGH一开始的初始值分别为$ H_{i-1}(0),H_{i-1}(1),…,H_{i-1}(7) $</p>
<p>Kt是第t个密钥，对应我们上文提到的64个常量</p>
<p>Wt是本区块产生第t个word。原消息被切成固定长度512-bit的区块，对每一个区块，产生64个word，通过重复运行循环n次对ABCDEFGH这八个字循环加密。</p>
<p>最后一次循环所产生的八个字合起来即是第i个块对应到的散列字符串$ H_{i} $</p>
</li>
</ol>
<h1 id="奇偶校验-Parity-Check"><a href="#奇偶校验-Parity-Check" class="headerlink" title="奇偶校验 (Parity Check)"></a>奇偶校验 (Parity Check)</h1><h2 id="参考链接-3"><a href="#参考链接-3" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/2301_80064376/article/details/140005268">奇偶校验原理（超详细）-CSDN博客</a></p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><strong>奇偶校验</strong>通过在数据末尾添加一个位，确保数据传输的正确性。<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C&spm=1001.2101.3001.7020">奇偶校验</a>分为<strong>奇校验</strong>和<strong>偶校验</strong>两种。<strong>奇偶校验通过设置规则来检查一组给定的位中1的数量</strong>。如果采用奇校验，每个数据单元中1的总数必须是奇数；如果采用偶校验，总数必须是偶数。</p>
<ul>
<li><strong>奇校验</strong>：如果数据单元中1的数量已经是奇数，则校验位设置为0；否则，校验位设置为1。</li>
<li><strong>偶校验</strong>：如果数据单元中1的数量已经是偶数，则校验位设置为0；否则，校验位设置为1。</li>
</ul>
<blockquote>
<p>[!important]</p>
<p><strong>计算机通过对所有信息位进行异或操作来实现求偶校验位和进行偶校验</strong>。这种方法简单有效，但只能检测到单个比特错误，无法检测多位错误。</p>
<p><strong>原理</strong>：奇偶校验通过计算数据中1的数量来判断数据是否被篡改。根据约定，可以是奇数校验或偶数校验。</p>
</blockquote>
<h2 id="奇偶校验在同步与异步传输中的应用"><a href="#奇偶校验在同步与异步传输中的应用" class="headerlink" title="奇偶校验在同步与异步传输中的应用"></a>奇偶校验在同步与异步传输中的应用</h2><p><strong>同步传输常用奇校验，而异步传输常用偶校验</strong>。这是因为同步传输中，全0数据采用奇校验时至少会有1个1，便于判断是否有传送发生；异步传输中，由于有停止位，采用偶校验时接收方也至少能收到1个1。</p>
<p><strong>奇偶校验电路实现</strong>：</p>
<ul>
<li><strong>偶校验位的产生</strong>：通过对待发送的数据依次做异或运算即可得到。</li>
<li><strong>奇校验位的产生</strong>：在偶校验电路的输出取非，产生奇校验位的代价高，速度相对慢。</li>
</ul>
<h2 id="栗子-2"><a href="#栗子-2" class="headerlink" title="栗子"></a>栗子</h2><h3 id="偶校验"><a href="#偶校验" class="headerlink" title="偶校验"></a>偶校验</h3><p>在偶校验中，校验位被设置为使得整个数据块（包括校验位）的1的个数为偶数。</p>
<ul>
<li>原数据：<code>1010001</code></li>
<li>1的个数：<code>3</code>（奇数）</li>
<li>校验位：<code>1</code>（使得1的总个数变为偶数）</li>
<li>校验后的数据：<code>10100011</code></li>
</ul>
<h3 id="奇校验"><a href="#奇校验" class="headerlink" title="奇校验"></a>奇校验</h3><p>在奇校验中，校验位被设置为使得整个数据块（包括校验位）的1的个数为奇数。</p>
<ul>
<li>原数据：<code>1010001</code></li>
<li>1的个数：<code>3</code>（奇数）</li>
<li>校验位：<code>0</code>（保持1的总个数为奇数）</li>
<li>校验后的数据：<code>10100010</code></li>
</ul>
<h3 id="校验过程"><a href="#校验过程" class="headerlink" title="校验过程"></a>校验过程</h3><ol>
<li><strong>发送方</strong>：在数据末尾添加校验位，形成校验单元后发送。</li>
<li><strong>接收方</strong>：重新计算校验位，并与接收到的校验位比对。如果相同，则数据传输正确；如果不同，则数据传输过程中出现错误。</li>
</ol>
<p><strong>类型</strong>：</p>
<ul>
<li><strong>单比特奇偶校验</strong>：针对单个数据单元（如字节）进行校验，能检测单个比特的错误。</li>
<li><strong>两维奇偶校验</strong>：在数据块的每行和每列都进行奇偶校验，能提供更强的错误检测能力。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">parity_check</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byte)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (byte) &#123;</span><br><span class="line">        count += byte &amp; <span class="number">1</span>;</span><br><span class="line">        byte &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count % <span class="number">2</span>;  <span class="comment">// 返回1表示奇数校验，0表示偶数校验</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data = <span class="number">0b10101100</span>;  <span class="comment">// 示例数据</span></span><br><span class="line">    <span class="type">int</span> parity = parity_check(data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parity: %d\n&quot;</span>, parity);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="纵向冗余校验（Longitudinal-Redundancy-Check，LRC）"><a href="#纵向冗余校验（Longitudinal-Redundancy-Check，LRC）" class="headerlink" title="纵向冗余校验（Longitudinal Redundancy Check，LRC）"></a>纵向冗余校验（Longitudinal Redundancy Check，LRC）</h1><h2 id="参考链接-4"><a href="#参考链接-4" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ZCShouCSDN/article/details/94131769">常用算法 之五 数据校验（CRC 原理、LRC、奇偶校验、校验和）详解_lrc校验-CSDN博客</a></p>
<h2 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h2><p>纵向冗余校验（LRC）是一种用于检测数据传输错误的常用方法，特别是在工业通信协议如Modbus ASCII模式中应用广泛。LRC的基本原理是通过对数据帧中的每个字节进行异或运算来生成一个校验字节，从而确保数据的完整性。</p>
<p>LRC的计算步骤如下：</p>
<ol>
<li><strong>数据处理</strong>：将需要校验的数据按字节排列，忽略起始和结束字符（如冒号和回车换行符）。</li>
<li><strong>异或运算</strong>：对所有字节进行异或运算。</li>
<li><strong>结果应用</strong>：将计算出的LRC值附加到数据帧的末尾，发送方和接收方都会计算LRC值并进行比较，如果两个值不相等，则表示数据传输过程中存在错误。</li>
</ol>
<p>LRC的主要优点在于其简单性和快速性，适用于小数据块的错误检测。然而，它也有明显的缺点，例如无法检测到偶数个位同时出错的情况。此外，LRC对突发错误的检测能力较弱，这意味着在某些情况下可能无法准确识别错误。</p>
<p>LRC校验广泛应用于工业通信协议中，如Modbus协议的ASCII模式，以及一些射频识别系统中。在这些场景中，由于标签容量有限，LRC因其简单高效而成为一种理想的选择。</p>
<p><img src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/19_19_53_38_202411191953885.png" alt="纵向冗余校验"></p>
<h2 id="栗子-3"><a href="#栗子-3" class="headerlink" title="栗子"></a>栗子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 LRC 校验值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">calculateLRC</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> lrc = <span class="number">0</span>;  <span class="comment">// 初始 LRC 校验值为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个字节逐位 XOR 计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        lrc ^= data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lrc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 假设我们有一组数据，每个字节为一个数据单元</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[] = &#123;<span class="number">0xD5</span>, <span class="number">0xB9</span>, <span class="number">0x7A</span>&#125;; <span class="comment">// 示例数据</span></span><br><span class="line">    <span class="type">int</span> data_length = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 LRC 校验值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> lrc = calculateLRC(data, data_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数据和计算的 LRC 校验值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; data_length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X &quot;</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nLRC: %02X\n&quot;</span>, lrc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://youshouldtrustme.github.io">ryf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://youshouldtrustme.github.io/2026/01/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%A0%A1%E9%AA%8C/">https://youshouldtrustme.github.io/2026/01/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%A0%A1%E9%AA%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://youshouldtrustme.github.io" target="_blank">🍭​你要信我啊の博客​</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/11/20_15_29_28_202411201529004.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/" title="编程规范"><img class="cover" src="/img/RandomCoverImage/random_11.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">编程规范</div></div><div class="info-2"><div class="info-item-1">参考链接C语言 | 嵌入式C语言编程规范_函数名开头加uc-CSDN博客  [!tip]  以下文件排版将会按照自顶向下的方式进行编排，&#x3D;&#x3D;文件夹 &gt; 文件名 &gt; 排版 &gt; 函数 &gt; 变量&#x3D;&#x3D;  文件架构缩写该项目文件树参考AUTOSAR结构，为了便于理解，此处展示部分缩写的全称：    缩写 全称 描述    AUTOSAR AUTomotive Open System ARchitecture 汽车开放系统架构，是汽车软件开发的标准框架。   ASW Application Software 应用软件，主要负责实现特定功能的业务逻辑。   BSW Basic Software 基础软件，负责底层硬件控制和通用服务的实现。   BSP Board Support Package 板级支持包，包含硬件初始化、驱动和相关工具。   HAL Hardware Abstraction Layer 硬件抽象层，提供对硬件的抽象访问接口。   MCAL Microcontroller Abstraction Layer 微控制...</div></div></div></a><a class="pagination-related" href="/2026/01/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/" title="测试基础"><img class="cover" src="/img/RandomCoverImage/random_10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">测试基础</div></div><div class="info-2"><div class="info-item-1">测试指标测试覆盖率测试覆盖率(（Test Coverage)是测试用例执行时，系统或代码的覆盖程度。它反映了测试是否覆盖了系统的各个方面，包括功能、代码、路径等。 不同的测试覆盖率指标提供了对测试的不同层面的检查。一般来说：  语句覆盖率和分支覆盖率是最常用的基础覆盖率，适用于大多数场景。 路径覆盖率和多条件覆盖率适用于复杂的系统，特别是那些有大量分支和复杂条件的系统。 函数覆盖率、调用路径覆盖率等适用于验证系统中的函数调用和路径的完整性。  功能覆盖率功能覆盖率（Functional Coverage）是指测试用例对系统中所有功能点的覆盖程度。它确保每个功能都得到了测试。计算方法为：$$功能覆盖率 &#x3D; （已执行的功能点数量 &#x2F; 总功能点数量）× 100%$$应用场景：  适用于验证系统是否实现了所有设计或需求文档中的功能。 适合功能测试，确保所有业务流程、用例和需求都已测试。  语句覆盖率语句覆盖率（Statement Coverage）是指测试用例执行过程中，程序中每个语句被执行的次数。它衡量了代码中每一行是否都被测试过。计算方法为：$$语句覆盖率 &#x...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">ryf</div><div class="author-info-description">嵌入式菜鸟</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/youShouldTrustMe"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C-Checksum"><span class="toc-number">1.</span> <span class="toc-text">校验和 (Checksum)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">1.1.</span> <span class="toc-text">参考链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%8F%8A%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.</span> <span class="toc-text">原理及步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%97%E5%AD%90"><span class="toc-number">1.3.</span> <span class="toc-text">栗子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C-CRC"><span class="toc-number">2.</span> <span class="toc-text">循环冗余校验 (CRC)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-1"><span class="toc-number">2.1.</span> <span class="toc-text">参考链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%97%E5%AD%90-1"><span class="toc-number">2.4.</span> <span class="toc-text">栗子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%A0%A1%E9%AA%8C-Hash-Check"><span class="toc-number">3.</span> <span class="toc-text">哈希校验 (Hash Check)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-2"><span class="toc-number">3.1.</span> <span class="toc-text">参考链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MD5%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">MD5摘要算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SHA256%E6%A0%A1%E9%AA%8C"><span class="toc-number">3.3.</span> <span class="toc-text">SHA256校验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.3.1.</span> <span class="toc-text">常量初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">3.3.2.</span> <span class="toc-text">信息预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">3.3.3.</span> <span class="toc-text">逻辑运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E8%AE%A1%E7%AE%97"><span class="toc-number">3.3.4.</span> <span class="toc-text">开始计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C-Parity-Check"><span class="toc-number">4.</span> <span class="toc-text">奇偶校验 (Parity Check)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-3"><span class="toc-number">4.1.</span> <span class="toc-text">参考链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E5%9C%A8%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">奇偶校验在同步与异步传输中的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%97%E5%AD%90-2"><span class="toc-number">4.4.</span> <span class="toc-text">栗子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.1.</span> <span class="toc-text">偶校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E6%A0%A1%E9%AA%8C"><span class="toc-number">4.4.2.</span> <span class="toc-text">奇校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">4.4.3.</span> <span class="toc-text">校验过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%B5%E5%90%91%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%EF%BC%88Longitudinal-Redundancy-Check%EF%BC%8CLRC%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">纵向冗余校验（Longitudinal Redundancy Check，LRC）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-4"><span class="toc-number">5.1.</span> <span class="toc-text">参考链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-1"><span class="toc-number">5.2.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%97%E5%AD%90-3"><span class="toc-number">5.3.</span> <span class="toc-text">栗子</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/21/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/QAC/" title="QAC"><img src="/img/RandomCoverImage/random_12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="QAC"/></a><div class="content"><a class="title" href="/2026/01/21/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/QAC/" title="QAC">QAC</a><time datetime="2026-01-21T02:07:02.616Z" title="发表于 2026-01-21 02:07:02">2026-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/21/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Qt/" title="Qt"><img src="/img/RandomCoverImage/random_5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt"/></a><div class="content"><a class="title" href="/2026/01/21/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Qt/" title="Qt">Qt</a><time datetime="2026-01-21T02:07:02.616Z" title="发表于 2026-01-21 02:07:02">2026-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/21/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Tessy/" title="Tessy"><img src="/img/RandomCoverImage/random_9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Tessy"/></a><div class="content"><a class="title" href="/2026/01/21/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Tessy/" title="Tessy">Tessy</a><time datetime="2026-01-21T02:07:02.616Z" title="发表于 2026-01-21 02:07:02">2026-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/21/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Vim/" title="Vim"><img src="/img/RandomCoverImage/random_16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vim"/></a><div class="content"><a class="title" href="/2026/01/21/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Vim/" title="Vim">Vim</a><time datetime="2026-01-21T02:07:02.616Z" title="发表于 2026-01-21 02:07:02">2026-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/21/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Vscode/" title="Vscode"><img src="/img/RandomCoverImage/random_2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vscode"/></a><div class="content"><a class="title" href="/2026/01/21/%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Vscode/" title="Vscode">Vscode</a><time datetime="2026-01-21T02:07:02.616Z" title="发表于 2026-01-21 02:07:02">2026-01-21</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2024 - 2026 By ryf</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async src="//at.alicdn.com/t/c/font_5020701_ump6lop7tzm.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://youshouldtrustme.github.io/categories/嵌入式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 嵌入式 (25)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://youshouldtrustme.github.io/categories/基础知识/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍼 基础知识 (13)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://youshouldtrustme.github.io/categories/编程语言/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍉 编程语言 (18)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://youshouldtrustme.github.io/categories/软件及工具/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 软件及工具的使用 (20)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://youshouldtrustme.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2026/01/21/嵌入式/通信协议/UDS/" alt=""><img width="48" height="48" src="https://gitee.com/you-trust-me/pictures/raw/master/Images/image-20251125085207933.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2026-01-21</span><a class="blog-slider__title" href="2026/01/21/嵌入式/通信协议/UDS/" alt="">UDS</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2026/01/21/嵌入式/通信协议/UDS/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2026/01/21/嵌入式/通信协议/SPI/" alt=""><img width="48" height="48" src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/09/14_13_52_58_202409141352788.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2026-01-21</span><a class="blog-slider__title" href="2026/01/21/嵌入式/通信协议/SPI/" alt="">SPI</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2026/01/21/嵌入式/通信协议/SPI/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2026/01/21/嵌入式/通信协议/IIC/" alt=""><img width="48" height="48" src="https://gitlab.com/18355291538/picture/-/raw/main/pictures/2024/09/13_13_59_26_202409131359673.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2026-01-21</span><a class="blog-slider__title" href="2026/01/21/嵌入式/通信协议/IIC/" alt="">IIC</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2026/01/21/嵌入式/通信协议/IIC/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2026/01/21/嵌入式/通信协议/CAN/" alt=""><img width="48" height="48" src="https://gitee.com/you-trust-me/pictures/raw/master/Images/image-20251125132704192.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2026-01-21</span><a class="blog-slider__title" href="2026/01/21/嵌入式/通信协议/CAN/" alt="">CAN</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2026/01/21/嵌入式/通信协议/CAN/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>